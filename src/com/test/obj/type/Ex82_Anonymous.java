package com.test.obj.type;

public class Ex82_Anonymous {

	public static void main(String[] args) {
		/*
		 * 익명 객체, Anonymous Object - 익명 클래스, Anonymous Class - 이름이 없는 클래스 - 반드시 인터페이스가
		 * 필요하다.(자바 특성) // 이름을 짓는 이유 > 다시 불러서 사용하려고 > 이름이 없으면 부르고 싶어도 못 부른다.
		 * 
		 * > 실명 클래스 
		 * - 클래스 선언(먼저) > 그 클래스로 객체 생성(미래)
		 *  
		 * > 익명 클래스 
		 * 1. 객체를 딱 1개만 만들 수 있다. - 1회용 클래스
		 * 클래스 선언 + 객체 생성 [둘의 시점이 동일하다.] / 그리고 더이상 객체를 만들 수 없다. 
		 * - 선언하고 그 시점이 지나면 이름이 없으니까
		 * 식별자가 없으니 못찾는다.
		 */
		// 요구사항] 인터페이스를 구현한 클래스 선언하기 > 객체를 생성하기(목적)
		
		//1. 본인 타입의 참조 변수
		BB o1 = new BB();
		o1.aaa();
		
		//2. 부모 타입의 참조 변수를 사용하는 경우도 있음
		AA o2 = new BB(); // 업캐스팅 > 참조변수는 인터페이스지만 실제로는 BB 라는 클래스가 만들어짐
		o2.aaa(); // 인터페이스로 상속이니까 참조타입을 본인으로 접근해도, 자식으로 접근해도 aaa는 있다.
		
		//3. 추상 클래스, 인터페이스 > 객체를 생성할 수 없다. > Why? > 추상메서드 때문... 
		// AA o3 = new AA(); //Cannot instantiate the type AA
		// o3.aaa(); // 이게 실행되도 사실상 아무일도 안일어나니까 막아둔 것이다. 
		// "껍데기만 있으니까" .. 오브젝트가 AA()일 수가 없음 > 오브젝트가 만들어져도 정상적인 동작을 못하니까.
		
		// 여기서 찍히는 에러메세지는 위와 다르다. 
		AA o4 = new AA() { // 이 블록은 아래 class BB 구현부와 동일하다. 
			@Override   // .... 여기의 클래스는 AA를 상속받는 이름없는 클래스를 선언 중이다.
			public void aaa() {  // 클래스를 선언한거기도 하지만 앞의 new롸 합쳐져서 오브젝트를 만든것과 같다.
				
				System.out.println("추상 메소드 구현2");
			} //The type new AA(){} must implement the inherited abstract method AA.aaa()
		}; // 여기서 세미클론을 찎는다.
		// 얘는 누구의 몸통인데 어떤 클래스의 몸통이다. 단지 누구인지 모른다. 특징은 AA라는 인터페이스가 추상메서드 물려줘서 구현하는 클래스
		// AA o4 = new AA() > 이표시가 헷갈리겠지만 이건 여기서 아무 역할을 안한다. 그냥 형식상 문법이다.
		// 그래서 익명 클래스 >이기도하고 > 익명 객체이기도 하다.
		// 이 인터페이스와 이 이름없는 클래스는 부모자식이다. 업케스팅 특징 때문에 부모 클래스에 자식을 넣을 수 있음.
		// 이 이름 없는 클래스를 AA라는 클래스의 자식이 되도록 자동으로 상속한다. AA-부모, 익명 클래스-자식, 업캐스팅됨
		
		o4.aaa(); // 
		// 익명 클래스는 객체를 하나밖에 못만든다. 1회용 클래스.
		
		AA o5 = new AA() { // 얘는 다른 클래스다.
			// ---- 밖에서 사용불가 ----
			public int a = 40;// 멤버변수 됨? 됨! 안에서는 사용가능하나 밖에서 접근불가 타입이 AA라.  
			@Override 
			public void aaa() {
				//a = 5; // 변수임 상수아님 !
				System.out.println("추상 메소드 구현2 : "+a);
				getA();
				a++;
			}
			public int getA() { //
				System.out.println("getA()");
				return this.a;
			} // ---- 밖에서 사용불가 ------ 타입이 AA라.
		};
		
		o5.aaa(); //
		o5.aaa(); //
		o5.aaa(); //
		o5.aaa(); //
		//o5로 a, getA() 참조불가
		
		
		//프로젝트
		// - 클래스 개수 > 캐!많음 > 수백개 ~ 수천개 이상
		// - 이름 짓기... 힘들다. > 영어 + 의미 : 웬만하면 클래스를 이젓저것 안늘리는 방법도 있다. 
		// 불필요하거나 무의미한 클래스는 안만드는 것이 좋다. 
		
	} // main
}

interface AA {
	void aaa(); // 
}

class BB implements AA { //////// 여기랑 동일하다. ////////
	@Override
	public void aaa() {
		System.out.println("추상 메소드 구현");
	}
}///////////////////////////////////////////////////////